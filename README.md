# Interactive-Classical-Ciphers-Analyzer
![image](https://github.com/user-attachments/assets/bb848691-2a2e-49c8-885b-90ac4278cf26)
![image](https://github.com/user-attachments/assets/5fa32cd1-39a0-4902-8901-a56b1f3554c3)
![image](https://github.com/user-attachments/assets/2cbdfb49-d496-4660-ab72-d53b63314f7d)
![image](https://github.com/user-attachments/assets/85f5dfe6-fe99-420e-a40d-35bdfbdbc658)
![image](https://github.com/user-attachments/assets/5a3f191b-54c5-4899-a872-62ebc4ec5ed4)
![image](https://github.com/user-attachments/assets/e7ef98ae-be6e-485a-a3f7-9a0a0faa5894)
![image](https://github.com/user-attachments/assets/44f81b60-d302-4f55-b726-f344c3e7eea4)
![image](https://github.com/user-attachments/assets/92a9915f-2726-421d-8b40-4149cb19a635)
![image](https://github.com/user-attachments/assets/6921306a-b4bd-436b-9efc-29c4b6401c29)
![image](https://github.com/user-attachments/assets/bbac401f-1b0f-400e-8661-6b421dd9cfce)
![image](https://github.com/user-attachments/assets/4cacdb5f-909b-4273-8437-c73f7e9778a2)
![image](https://github.com/user-attachments/assets/ddbbae86-68b4-467b-b898-903321623719)
![image](https://github.com/user-attachments/assets/279a7120-08e8-425b-9631-08c31a31348a)
![image](https://github.com/user-attachments/assets/9081cbe3-79e8-4317-b767-be7f4461f1be)
![image](https://github.com/user-attachments/assets/81248b7a-c0f4-4d1f-8676-a76cbb56ff65)

# Analysis and Implementation of Classical Substitution Ciphers in Python
## Abstract
This report provides a comprehensive analysis of two fundamental classical cryptographic algorithms: the Shift Cipher (commonly known as the Caesar Cipher) and the Monoalphabetic Substitution Cipher. It delves into their underlying algorithmic principles, examines their practical implementations using Python, explores their historical significance, and critically assesses their cryptographic vulnerabilities in the context of modern security standards.
The analysis demonstrates that while these ciphers were historically pivotal in establishing the foundational concepts of cryptography, their inherent simplicity—characterized by small key spaces and fixed substitution patterns—renders them highly susceptible to cryptanalytic attacks such as brute-force enumeration and frequency analysis. Consequently, they offer negligible security for contemporary communication requirements. The methodology employed integrates a detailed review of the provided Python code with an in-depth exploration of cryptographic theory, historical context, and a comparative analysis against modern cryptographic paradigms. Specific attention is paid to the roles of Python's built-in functions, including ord(), chr(), str.maketrans(), and translate(), in their programmatic implementation.
In conclusion, despite their cryptographic obsolescence for secure communication, the Shift and Monoalphabetic Substitution Ciphers retain significant value as pedagogical tools. They serve as accessible entry points for understanding core cryptographic concepts and vividly illustrate the evolutionary trajectory from rudimentary "art" to the mathematically rigorous "science" that defines modern cryptography.
## 1. Introduction to Classical Cryptography
### 1.1 Historical Context and Foundational Concepts
Cryptography, the practice of secure communication in the presence of adversarial third parties, possesses a rich and intricate history that extends back to ancient civilizations such as Rome and Egypt.1 Early cryptographic endeavors highlight a fundamental human need to protect sensitive information. For instance, non-standard hieroglyphs carved into Egyptian tomb walls around 1900 BC suggest early attempts at concealing meaning.2 Similarly, clay tablets from Mesopotamia, dated near 1500 BC, contained enciphered writings believed to be secret recipes for pottery glaze, representing an early form of trade secret protection.2 Hebrew scholars, around 600-500 BC, also employed simple monoalphabetic substitution ciphers, such as the Atbash cipher.2 Beyond substitution, the Spartan military famously utilized the scytale, a transposition cipher, to scramble the order of letters in military communications, demonstrating an early understanding of message rearrangement for security.2
Prior to the advent of widespread computing and formalized mathematical frameworks, classical cryptography was often perceived as an "art" rather than a systematic science. Its methods relied heavily on manual processes and the individual creativity of those devising the ciphers.4 This historical context reveals a compelling progression in the purpose and scale of cryptography. Initially, it addressed very specific, localized needs, such as ensuring military advantage for figures like Julius Caesar or safeguarding commercial secrets. As societies grew in complexity and the volume and criticality of information exchange increased, the demand for secure communication expanded significantly. This indicates a direct relationship between societal advancement, the perceived value of information, and the subsequent drive for more sophisticated and scalable cryptographic methods. The early "art" form of cryptography reflects a nascent understanding where security frequently depended on the obscurity of the method rather than its inherent mathematical robustness.
The continuous cycle throughout history of humans inventing increasingly complex information-hiding schemes and other humans subsequently breaking them 1 underscores a perpetual "arms race" in the domain of information security. This dynamic illustrates that cryptographic advancements are not merely isolated technological innovations but rather a continuous and adaptive response to the inherent vulnerability of information. This vulnerability is driven by strategic, commercial, and personal imperatives to protect sensitive data from unauthorized access and interception. The very act of encryption, therefore, arises from the perceived threat of compromise and the necessity to maintain confidentiality.
1.2 Overview of Substitution Ciphers
Substitution ciphers constitute one of the oldest and most fundamental categories of encryption algorithms in the history of cryptography.5 Their core principle involves transforming plaintext into ciphertext by replacing each character (or, in some cases, elements like digraphs or trigraphs) with a different character or symbol based on a predefined mapping or rule.5 This mapping can range from remarkably simple schemes, such as shifting letters a fixed number of positions within the alphabet, to more intricate arrangements involving a completely random permutation of the alphabet.6 The process of decryption is achieved by applying the inverse of the original substitution, reversing the mapping to retrieve the original plaintext.6
Substitution ciphers are broadly classified into two primary types: monoalphabetic and polyalphabetic ciphers.6 This classification is based on whether a single, fixed substitution alphabet is used throughout the entire message (monoalphabetic) or if multiple substitution alphabets are employed, changing during the encryption process (polyalphabetic).
The fundamental idea behind substitution, while conceptually straightforward, inherently leaves a "trace" – the statistical properties of the original language. By merely substituting symbols, these ciphers typically preserve the underlying statistical patterns of the plaintext, such as letter frequencies. This inherent preservation of statistical patterns is precisely why frequency analysis emerged as such a powerful cryptanalytic tool.3 This reveals a critical tension: the simplicity that makes substitution ciphers easy to understand and implement 11 is simultaneously their greatest cryptographic weakness. This represents a fundamental trade-off that classical cryptography largely struggled to overcome.
The widespread adoption of substitution ciphers, particularly monoalphabetic ones, directly spurred the development of systematic cryptanalytic techniques. Al-Kindi's invention of frequency analysis around 800 AD 2 was a direct response to the prevalence of these ciphers. This historical development demonstrates a clear cause-and-effect relationship: the characteristics of prevalent encryption methods directly drive innovation in methods designed to break them. This ongoing interplay between cipher design and cryptanalysis is a defining feature of the entire history of cryptography, pushing the field towards increasingly sophisticated and robust algorithms.
## 2. The Shift Cipher (Caesar Cipher)
### 2.1 Algorithmic Principles and Mathematical Foundation
The Shift Cipher, universally recognized as the Caesar Cipher, represents one of the simplest forms of substitution ciphers. In this technique, each letter in the plaintext is systematically replaced by another letter found by shifting a fixed number of positions down the alphabet.13 Its historical prominence stems from its use by Julius Caesar, who famously employed it, typically with a shift value of three, to secure military communications.3
The Shift Cipher operates as a symmetric encryption scheme, which means that the identical key—the numerical shift value—is utilized for both the encryption and decryption processes.13 This key is an integer, denoted as n or k, representing the specific number of positions each letter is to be shifted.11
The mathematical foundation of the Shift Cipher relies on modular arithmetic. For encryption, if x represents the numerical position of a plaintext letter (where A=0, B=1,..., Z=25), and n is the shift key, the corresponding ciphertext letter C is derived using the formula:
E_n(x) = (x + n) mod 26.5
Conversely, to decrypt a ciphertext letter y, the original plaintext letter P is recovered using the formula:
D_n(y) = (y - n) mod 26.5
The modulo 26 operation is a critical component of these formulae. It ensures that the result of the shift, regardless of how large it becomes, always "wraps around" the alphabet, keeping the transformed character within the 26-letter range of the English alphabet.13 For example, if 'Z' (position 25) is shifted by 3, the result is (25+3) mod 26 = 28 mod 26 = 2, which corresponds to 'C'.
The consistent application of the mod 26 operation is not merely a mathematical detail; it is the defining characteristic that enables the fixed, cyclical substitution of the Caesar cipher. This elegant mathematical concept allows letters to "wrap around" the alphabet, which is essential for the cipher's functionality. However, this very elegance also introduces a fundamental constraint: the key space is limited to precisely 26 possibilities. This finite and predictable nature, while simplifying implementation, becomes a severe security vulnerability.
The reliance on a "fixed key" for the Shift Cipher 5 is a fundamental aspect of its design. This fixed nature, coupled with the extremely small key space of 26 possibilities, directly leads to its profound vulnerability to brute-force attacks.13 While the simplicity of managing a single numerical key was advantageous for ease of use in ancient times, it represents a catastrophic disadvantage in terms of security. This highlights a foundational trade-off in early cipher design: simplicity of operation often came at the cost of cryptographic strength.
### Table 1: Shift Cipher Encryption/Decryption Formulae
![image](https://github.com/user-attachments/assets/561b5df3-ad17-462b-a2b2-d58b3236fd98)

 ### 2.2 Python Implementation Analysis: shift_cipher_encrypt
The provided Python function shift_cipher_encrypt effectively translates the algorithmic principles of the Shift Cipher into executable code. The function iterates through each character of the input plaintext string. Within this loop, it incorporates conditional logic to differentiate between uppercase ('A'-'Z') and lowercase ('a'-'z') letters. This distinction is crucial for preserving the original casing of the plaintext during encryption.
For each alphabetic character, its numerical position (0-25) within its respective alphabet (A-Z or a-z) is determined by subtracting the Unicode ordinal value of 'A' or 'a' (e.g., ord(char) - ord('A')). The core shift operation, (original_pos + key) % 26, is then applied to this numerical position. This ensures that the result correctly wraps around the alphabet, maintaining the cyclical nature of the cipher. Subsequently, the shifted numerical position is converted back to its corresponding Unicode ordinal value by adding ord('A') or ord('a') back. Finally, the chr() function converts this Unicode ordinal back into its character representation, which is then appended to the accumulating ciphertext string. Any non-alphabetic characters encountered (such as spaces, numbers, or punctuation) are appended to the ciphertext without modification, preserving their original form.
#### 2.2.1 Role of ord() and chr() Functions
The ord() and chr() functions are indispensable built-in Python functions that facilitate the manipulation of characters by converting them to and from their numerical Unicode code points. The ord() function takes a single Unicode character as input and returns its corresponding integer Unicode code point value. For example, ord('A') yields 65, and ord('a') yields 97.17 Conversely, the chr() function performs the inverse operation, converting an integer Unicode code point back into its character representation; for instance, chr(65) returns 'A'.17 These functions are complementary and are essential for implementing cryptographic algorithms like the Shift Cipher, as they enable the direct application of mathematical operations (such as shifting and modulo) on textual data.17 It is important to note that ord() strictly requires a single character as input; providing a string with more than one character will result in a TypeError.17 The chr() function is capable of handling any valid Unicode point within the extensive range of 0 to 1,114,111, encompassing characters from virtually all modern written languages, symbols, and emojis.18
The utility of ord() and chr() functions extends beyond simple conversion; they abstract away the underlying complexities of character encoding. This abstraction allows developers to treat textual characters as straightforward numerical values, thereby enabling the direct application of mathematical operations that define the cipher's logic. This demonstrates a critical aspect of modern programming: how high-level language features bridge the gap between abstract mathematical concepts and concrete data manipulation, making cryptographic algorithms computable and implementable in software.
Furthermore, the reliance of ord() and chr() on the Unicode standard 17 implies that the correctness and interoperability of the cipher implementation are inherently dependent on a universally accepted character encoding system. If different computing environments utilized disparate numerical representations for the same characters, the cipher would fail to produce consistent results across platforms. This highlights that even seemingly simple ciphers implicitly depend on underlying computational infrastructure and international standards to function correctly, foreshadowing the complex dependencies within modern cryptographic systems that operate on binary data streams.
### Table 2: ord() and chr() Examples in Cipher Context

![image](https://github.com/user-attachments/assets/1fe85780-949d-4717-9963-5649b942e6b8)

 2.3 Cryptographic Strengths and Weaknesses
While the Shift Cipher possesses certain historical and pedagogical merits, its cryptographic strengths are severely limited, rendering it entirely unsuitable for any serious security applications in the modern era.
Perceived Strengths (Historical/Pedagogical):
Historically, the Shift Cipher was remarkably simple to learn and implement, requiring minimal inputs and computing resources.6 This simplicity made it accessible for basic encryption tasks in ancient times, providing a rudimentary level of security by rendering messages unintelligible to those unaware of the method.12 Today, its straightforward nature makes it an excellent teaching tool for introducing fundamental cryptographic concepts, such as plaintext, ciphertext, keys, and basic encryption/decryption processes.6
Fundamental Weaknesses (Modern Context):
Despite its historical utility, the Shift Cipher is considered extremely weak and offers negligible security by modern standards.1 Its primary vulnerabilities include:
●	Small Key Space: The English alphabet comprises only 26 letters, which means there are only 26 possible shift values (0 through 25) that can be used as keys.1 A shift of 0 (or 26) results in an identity mapping, where the plaintext remains unencrypted. This extremely limited key space is its most significant flaw.
●	Vulnerability to Brute-Force Attack: Due to the minuscule key space, the cipher can be trivially broken by systematically trying every single possible shift value (a brute-force attack).6 Modern computers can perform all 25 non-identity shifts in a matter of milliseconds, making this attack highly efficient and guaranteed to succeed.14
●	Vulnerability to Frequency Analysis: As a monoalphabetic substitution cipher, the Shift Cipher maintains a one-to-one mapping where each plaintext letter consistently maps to the same ciphertext letter. This property inherently preserves the underlying letter frequency distribution of the plaintext within the ciphertext.1 Cryptanalysts can exploit these statistical patterns—for example, knowing that 'E' is the most common letter in English—to deduce the shift key by observing the most frequent letter in the ciphertext.3
●	Composition of Shifts: Applying multiple Shift Cipher operations sequentially (e.g., encrypting with a shift of 'a' and then further encrypting with a shift of 'b') does not enhance the cipher's security. The combined effect of such successive shifts is cryptographically equivalent to a single shift of (a + b) mod 26.14 This means layering Shift Ciphers offers no additional cryptographic strength.
●	Predictable Pattern: The consistent and simple substitution rule creates a highly predictable pattern in the ciphertext, which is easily discernible by an attacker.11
Historically, the Caesar cipher was effective primarily because its method was "not widely known".1 This exemplifies "security through obscurity"—the flawed notion that a system is secure simply because its internal workings are secret. However, modern cryptography operates on Kerckhoff's Principle 4, which posits that a cryptosystem should be secure even if everything about it is known except the encryption key. The Caesar cipher's rapid failure against known cryptanalytic methods, such as brute force and frequency analysis, starkly demonstrates the inherent fragility and unreliability of obscurity as a primary security measure.
The effectiveness of brute-force attacks against the Caesar cipher is directly proportional to the available computational power.13 What was once a tedious, time-consuming task for human cryptanalysts (manually trying 25 shifts) became utterly trivial for early computers. This illustrates a fundamental and ongoing trend in cryptography: advancements in computing power continuously challenge the security of existing cryptographic schemes. This necessitates the relentless development of increasingly complex, computationally intensive, and mathematically robust algorithms to maintain any semblance of security against evolving computational capabilities.
### 2.4 Analysis of Provided Code Execution and Results
The provided Python script demonstrates the practical application of the shift_cipher_encrypt function. When executed, the script prompts the user to enter plaintext for the Shift Cipher. For a fixed key of 15, the shift_cipher_encrypt function processes the input.
For example, if the user enters AN TOAN as plaintext, the shift_cipher_encrypt function will process each character. Given the key k = 15, the expected ciphertext generated by the shift_cipher_encrypt function would be PC IDPC. This is derived as follows:
 ![image](https://github.com/user-attachments/assets/4ffc14b6-a6fd-420b-9023-78e996f6e627)

The script also includes a dedicated "Module Operation for 'AN TOAN'" section, which provides a detailed, character-by-character breakdown of the encryption process specifically for the string "ANTOAN" (without spaces). This section explicitly shows the ordinal value calculations, the addition of the key, the modulo 26 operation, and the final character conversion, confirming the transformation of "ANTOAN" to "PCIDPC".
It is important to note a discrepancy between the expected output from the provided code and the example output PZ EDPAZ shown in the user's query for "AN TOAN". Based on the shift_cipher_encrypt function and the detailed module operation for a key of 15, the correct output for "AN TOAN" (preserving the space) should be "PC IDPC", and for "ANTOAN" (no space) should be "PCIDPC". This highlights the critical necessity of meticulous implementation and rigorous verification in cryptography. Even a minor deviation in understanding the algorithm's rules or a simple typo can lead to incorrect ciphertext, rendering the encryption ineffective or causing decryption failures. This underscores that cryptographic integrity is not solely dependent on the strength of the algorithm but equally on its flawless and precise execution.
The inclusion of the step-by-step "Module Operation" in the provided code is an excellent demonstration of how to enhance transparency and debuggability in cryptographic implementations. By explicitly showing the intermediate numerical transformations (ordinal values, shifts, modulo results), it allows for direct, character-by-character verification of the algorithm's correctness. This level of transparency is invaluable for building trust in cryptographic software, as it enables developers and auditors to precisely trace the flow of data and identify any deviations from the intended logic, especially in a field where errors can have severe security implications. Furthermore, the code's handling of non-alphabetic characters (preserving them) and its conversion of input to uppercase highlight practical considerations in cipher implementation. While simple for these classical ciphers, in real-world cryptography, robust handling of diverse character sets, punctuation, and whitespace is crucial. This subtly points to the broader challenge of input sanitization and character encoding in cryptographic systems, where mishandling can introduce vulnerabilities or lead to incorrect results.
## 3. The Monoalphabetic Substitution Cipher
### 3.1 Algorithmic Principles and Key Mapping
The Monoalphabetic Substitution Cipher, often referred to as the "Simple Substitution Cipher," is an encryption method where each character in a plaintext message is consistently replaced with a new, corresponding character in the ciphertext using a predefined substitution method.5 The cipher operates via a specific key mapping function, denoted as K, which dictates that a plaintext character α is always replaced by its corresponding ciphertext character K(α).5 The prefix "Mono-" underscores that each letter of the plaintext has a single, unique, and consistent substitution throughout the entire encryption process.5 This implies a one-to-one and constant relationship between plaintext and ciphertext symbols.5 The Shift Cipher (Caesar Cipher) is, in fact, a specific instance of a monoalphabetic cipher where the substitution mapping is a simple cyclic shift.5
A key distinction from the Shift Cipher lies in the key space. Unlike the Shift Cipher's severely limited key space of 26 possibilities, the Monoalphabetic Substitution Cipher allows for a random permutation of all 26 letters of the alphabet. This results in an astronomically larger key space of 26! (factorial 26) possible keys, which translates to approximately 4 x 10^26 unique permutations.5 This immense number of keys, in the pre-computer era, made brute-force attacks seem computationally infeasible, giving it a perceived strength over simpler substitution ciphers.5
However, this very large key space presents a paradox regarding cryptographic strength. While the sheer number of permutations initially made brute-force attacks seem impractical, monoalphabetic ciphers are universally considered weak 5 due to their susceptibility to frequency analysis. This reveals a critical cryptographic principle: a large key space alone is insufficient to guarantee security if the underlying structural or statistical properties of the plaintext are preserved in the ciphertext. The method of substitution and its impact on statistical patterns are more crucial than just the sheer number of possible keys.
The inherent vulnerability of monoalphabetic ciphers to frequency analysis 3 is a direct consequence of the statistical regularities present in natural languages. These include the predictable frequencies of individual letters (e.g., 'E' being the most common in English), common digrams (two-letter combinations like "TH"), and trigrams (three-letter combinations like "THE").8 By maintaining a consistent one-to-one substitution, these ciphers fail to obscure these inherent linguistic patterns. This demonstrates that cryptanalysis is not purely a mathematical or computational problem but often involves leveraging linguistic knowledge and statistical analysis, highlighting the interdisciplinary nature of cryptography as it evolved.
### 3.2 Python Implementation Analysis: monoalphabetic_encrypt
The monoalphabetic_encrypt function provided in the Python code efficiently implements the Monoalphabetic Substitution Cipher. The function accepts two primary arguments: the plaintext to be encrypted and a key, which represents the complete 26-letter substitution alphabet.
The implementation begins by defining a standard English alphabet string: alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ". To ensure consistency in mapping, the input key is converted to uppercase using key.upper(). The core of the substitution process is orchestrated by str.maketrans(alphabet, key). This method generates a translation table, which is essentially a precise mapping where each character in the alphabet string is mapped to its corresponding character at the same position in the key string. Before the translation is applied, the plaintext is also converted to uppercase (plaintext.upper()). Finally, the translate() method, invoked on the uppercase plaintext string, applies this generated mapping to produce the ciphertext. Characters not present in the alphabet (e.g., spaces, punctuation) are preserved unchanged by the translate method.
#### 3.2.1 Role of str.maketrans() and translate() Methods
The str.maketrans() method is a static method of Python's built-in str class, specifically designed to create translation tables. These tables serve as precise mappings of Unicode ordinal values (or characters) to other Unicode ordinals, strings, or None.20 Once created, this translation table is then utilized by the translate() method of a string object to perform efficient character replacements or removals.20
maketrans() offers considerable flexibility in how these mappings are defined:
●	It can accept a dictionary where key-value pairs explicitly define the character mapping (e.g., {'a': '1'}).20
●	It can take two strings of equal length. In this scenario, characters in the first string are mapped to characters at the corresponding positions in the second string (e.g., str.maketrans('aeiou', '12345')). This is precisely the method employed in the provided monoalphabetic_encrypt function, where the standard alphabet is mapped to the custom key.20
●	An optional third string parameter can be provided to specify characters that should be removed from the target string (by mapping them to None).20
These methods are highly versatile and are commonly employed for various string manipulation tasks beyond cryptography, including data cleaning, text preprocessing, and standardizing character sets.20
When compared to the shift_cipher_encrypt function, which employs a character-by-character loop with ord() and chr(), the str.maketrans() and translate() methods offer a significantly more concise and potentially more performant approach for performing bulk character substitutions.20 This demonstrates how leveraging Python's optimized built-in functionalities can lead to more efficient and readable cryptographic code, especially for operations involving fixed, predefined mappings across an entire string. It underscores the value of choosing appropriate language features for optimal implementation.
The choice between ord()/chr() and maketrans()/translate() for character manipulation in Python reflects a common design trade-off in programming. While ord() and chr() provide granular control over individual character transformations (which is beneficial for dynamic shifts or complex character sets), maketrans() and translate() are highly optimized for applying a fixed, static mapping across an entire string. This implies a strategic decision in implementing cryptographic algorithms: whether to prioritize fine-grained control (potentially at the cost of verbosity or performance for large strings) or to utilize highly optimized built-in functions for fixed, bulk transformations. This decision impacts both development complexity and runtime efficiency of the cipher.
### Table 3: str.maketrans() and translate() Examples
 ![image](https://github.com/user-attachments/assets/758b2ff7-ecfe-43ed-9cb1-f64ea2d93583)

### 3.3 Cryptographic Strengths and Weaknesses (Focus on Frequency Analysis)
The Monoalphabetic Substitution Cipher, despite its seemingly large key space, possesses fundamental cryptographic weaknesses that render it insecure for any modern application.
Perceived Strengths (Historical):
Historically, the Monoalphabetic Substitution Cipher was considered more robust than the simple Shift Cipher due to its significantly larger key space. With 26! (approximately 4 x 10^26) possible keys, a brute-force attack was computationally infeasible in the pre-computer age.5 This vast number of permutations gave it a deceptive appearance of strength, making it a more challenging cipher to break manually compared to the Caesar cipher's mere 26 keys.5
Fundamental Weaknesses:
Despite its large key space, the Monoalphabetic Substitution Cipher is highly vulnerable to cryptanalytic attacks, particularly frequency analysis.3 It is not considered safe for serious security applications.5 The core reasons for this vulnerability include:
●	Preservation of Frequency Distribution: The most critical flaw lies in its "fixed key substitution" 5 and the "one-to-one connection" between plaintext and ciphertext symbols.5 This means that if, for example, the letter 'E' is always mapped to 'Q' in the ciphertext, then the frequency of 'Q' in the ciphertext will directly correspond to the frequency of 'E' in the plaintext. The frequency distributions of letters in the plaintext are preserved identically in the ciphertext; only the symbols are relabeled.10
●	Exploitation of Linguistic Patterns: Any underlying statistical structure or pattern inherent in the plaintext, such as the predictable frequencies of individual letters (e.g., 'E', 'T', 'A' being common in English), common digrams (e.g., "TH", "ER", "ON"), and trigrams (e.g., "THE", "AND", "ING") 8, remains intact within the ciphertext. This simplifies the task for a cryptanalyst, who can analyze the ciphertext to identify these patterns and deduce the substitution key.10
●	Redundancy of Language: Due to the inherent redundancy of the English language, a cryptanalyst needs only about 25 symbols of ciphertext to perform effective cryptanalysis on monoalphabetic substitution ciphers.10 This makes them a popular choice for recreational cryptograms, precisely because they are relatively easy to break.
●	Fixed Key Substitution: The consistent nature of the substitution, where each plaintext letter always maps to the same ciphertext letter, is a fundamental vulnerability.5
The core weakness of monoalphabetic ciphers stems from their "fixed substitution" 5 and "one-to-one connection".5 This predictability, regardless of the key's complexity, is the fundamental flaw that frequency analysis exploits.10 It reveals that the nature of the transformation is more critical for security than the sheer number of possible transformations.
Al-Kindi's invention of frequency analysis around 800 AD 2 was a "single most significant cryptanalytic advance until World War II".2 This was not merely a clever trick; it marked a profound shift from ad-hoc cipher breaking to a more systematic, statistical approach. It transformed cryptanalysis into a nascent science, demonstrating that language itself, with its inherent statistical regularities, could be a powerful tool for breaking codes. This development forced future cipher designers to account for these linguistic properties, thereby pushing the field towards greater complexity.
### 3.4 Analysis of Provided Code Execution and Results
The provided Python script also demonstrates the operation of the monoalphabetic_encrypt function. When executed, the script prompts the user for plaintext. It then applies a predefined, hardcoded key: "DKVQFIBJWPESCXHTMYAUOLRGZN".
For instance, if the user enters "HELLO WORLD" as plaintext, the monoalphabetic_encrypt function will convert it to uppercase and then apply the substitution mapping. Based on the provided key, the encryption process would yield the following ciphertext:
 ![image](https://github.com/user-attachments/assets/8a17f5bf-ec67-49fe-8869-0232df0ec7ff)

The resulting ciphertext from a monoalphabetic cipher, especially with a jumbled key, appears highly randomized and unintelligible to the casual observer. This creates a strong visual sense of security. However, as discussed, this visual obscurity belies the underlying statistical predictability.10 The apparent randomness is superficial, as the fixed one-to-one mapping ensures that the frequency distribution of characters remains unchanged, making it vulnerable to analysis. This highlights the crucial difference between perceived security and actual cryptographic strength.
While the provided code uses a hardcoded key, the generation of a truly random permutation of 26 letters (26! possibilities) for a manual monoalphabetic cipher key is a non-trivial task for humans. The sheer number of permutations 5 makes it impractical to randomly choose one without computational aid. This practical difficulty in key generation, even for a theoretically large keyspace, underscores the limitations of manual classical cryptography and hints at the necessity of automated, robust key generation methods in modern systems.
## 4. Comparative Analysis and Evolution of Ciphers
### 4.1 Shift Cipher vs. General Monoalphabetic Cipher
The Shift Cipher (Caesar Cipher) and the general Monoalphabetic Substitution Cipher share a fundamental commonality: both are types of substitution ciphers that replace plaintext characters with ciphertext characters.5 However, they differ significantly in their key space and the nature of their substitution rule.
The Shift Cipher is a highly specific instance of a monoalphabetic cipher, characterized by its fixed shift rule (ee.g., shifting by +3 positions).13 This rigid rule limits its key space to a mere 26 possible keys (corresponding to shifts from 0 to 25).13 In contrast, a general Monoalphabetic Substitution Cipher employs a completely jumbled substitution alphabet, allowing for any permutation of the 26 letters. This expands its key space dramatically to 26! (factorial 26) possible keys, a number vastly larger than that of the Shift Cipher (approximately 4 x 10^26).5
Despite this profound difference in key space, both ciphers share a critical vulnerability: they are highly susceptible to frequency analysis.8 This weakness arises because both maintain a one-to-one mapping between plaintext and ciphertext characters, thereby preserving the underlying letter frequencies of the plaintext within the ciphertext. The Shift Cipher is inherently easier to break due to its extremely small key space, allowing for rapid brute-force attacks.5 The general Monoalphabetic Cipher, while resistant to brute-force in the pre-computer age due to its large key space, still succumbs easily to frequency analysis.
This comparison reveals that "simple substitution" is not a monolithic concept but rather a spectrum of complexity. The Caesar cipher represents the simplest end, with its highly constrained key space and predictable shift. The general monoalphabetic cipher, while still "simple" in its one-to-one mapping, offers a much larger key space. This illustrates that complexity in key generation does not necessarily translate to cryptographic strength if the underlying weakness (frequency analysis) remains unaddressed. This serves as a lesson in identifying the true vulnerabilities beyond superficial key size.
The historical evolution from Caesar's 26 keys to the 26! keys of a general monoalphabetic cipher 5 reflects an early, intuitive attempt to increase security by expanding the "key space" and making brute-force attacks harder. This historical progression shows cryptographers trying to make their ciphers more robust, even if the fundamental cryptanalytic techniques (like frequency analysis) were not yet fully understood or widely applied against the more complex variants. This drive for larger keyspaces continues into modern cryptography.
### 4.2 Transition to Polyalphabetic Ciphers
The inherent vulnerability of monoalphabetic ciphers to frequency analysis prompted the development of more sophisticated classical encryption methods, leading to the emergence of polyalphabetic ciphers. Polyalphabetic substitution ciphers represent a significant advancement because they utilize multiple substitution alphabets rather than just one.1 This approach directly counters the primary weakness of monoalphabetic ciphers: their susceptibility to frequency analysis.3
In a polyalphabetic cipher, the relationship between plaintext and ciphertext letters changes dynamically during the encryption process.7 This is typically achieved by using a keyword that dictates which of several substitution alphabets is applied to each successive plaintext letter. The Vigenère Cipher is the most well-known example of a polyalphabetic cipher, employing a keyword to determine which Caesar shift (from 0 to 25) is applied to each letter.1 Historically, the Vigenère Cipher was considered secure for centuries, earning the moniker "le chiffre indéchiffrable" (the indecipherable cipher), until cryptanalytic methods like Kasiski examination were popularized in the 19th century.7 Leon Battista Alberti, in 1467, is often regarded as the father of modern cryptography for his pioneering exploration of polyphonic cryptosystems, which laid the groundwork for these multi-alphabet ciphers.3
Polyalphabetic ciphers, by using multiple alphabets, aim to "flatten" the frequency distribution of letters in the ciphertext 8, making frequency analysis much harder. This is an early manifestation of the cryptographic principle of "diffusion" 8, where the influence of a single plaintext character is spread over multiple ciphertext characters. This represents a conscious design effort to break the one-to-one mapping that plagued monoalphabetic ciphers, a crucial step towards more robust encryption.
Even polyalphabetic ciphers like Vigenère, once considered "uncrackable for almost three centuries" 4, eventually succumbed to advanced cryptanalytic techniques like Kasiski examination.7 This reinforces the historical pattern of an ongoing arms race: as ciphers become more complex, cryptanalytic methods evolve to break them. This dynamic is a constant driving force in cryptographic innovation, leading to increasingly sophisticated algorithms.
### 4.3 Classical vs. Modern Cryptography: Fundamental Differences
The evolution from classical ciphers to modern cryptography represents a profound paradigm shift in the field, driven primarily by advancements in computational power and mathematical theory.
Classical Cryptography:
Classical cryptography, largely pre-dating World War II, involved converting plaintext into ciphertext primarily through manual methods, often relying on substitution and transposition techniques.4 It was considered an "art," lacking the formalized mathematical rigor of modern methods, and its strength often depended on the ingenuity of its creator.4 Classical ciphers, including the Caesar cipher, Vigenère cipher, and even the more complex Enigma machine, were highly vulnerable to cryptanalytic techniques like frequency analysis and brute-force attacks, particularly with the advent of computational tools.4 A significant limitation was its reliance on "security through obscurity," where the effectiveness of the cipher often depended on keeping the algorithm itself secret.4 This made them susceptible to compromise if the method was discovered. Furthermore, classical cryptography was not designed for large-scale data handling, with most processes being manual and thus limiting scalability.4 Its primary application was largely confined to military and diplomatic communications.4
Modern Cryptography:
Modern cryptography emerged post-World War II, fundamentally transformed by the influence of technology and computing power. It is now considered an "exact science," employing complex mathematical algorithms to secure communication, data storage, and information across virtually all aspects of digital life.4 A cornerstone of modern cryptography is Kerckhoffs' Principle, which dictates that the security of a cryptosystem should rely solely on the secrecy of the encryption key, with the algorithm itself being publicly known and open to scrutiny.4 This stands in stark contrast to the classical reliance on algorithm secrecy.
Modern cryptography offers numerous advantages:
●	Seamless Integration: It is seamlessly integrated into everyday life, often without users' conscious awareness, securing activities from starting a car to online banking.4
●	Speed: Thanks to advanced technology and computational power, even highly complex algorithms can execute in microseconds.4
●	Broad Reach: Its protective scope extends across diverse environments, including communication channels, data storage, applications, cloud platforms, and Internet of Things (IoT) devices.4
●	Secure Key Exchange: Modern methods provide secure key exchange mechanisms, enabling parties to establish shared secret keys over insecure channels without physical meetings.4
●	Comprehensive Security Guarantees: Beyond mere confidentiality, modern cryptography offers guarantees of data integrity, authenticity, and non-repudiation.4
●	Public Key Infrastructure (PKI): The generation and verification of digital certificates, central to PKI, are vital to its success.4
Despite its robustness, modern cryptography faces challenges, including its dependence on computational power (with quantum computing posing a future risk if algorithms are not upgraded) and its potential exploitation by hackers for new forms of attacks like ransomware.4
The most profound difference is the shift from relying on algorithm secrecy (classical) to relying on key secrecy (modern), encapsulated by Kerckhoff's Principle.4 This is not just a technical change but a philosophical one. It implies that modern cryptographic systems are designed to be robust even if their internal workings are fully known, with security residing solely in the unpredictability of the key. This design philosophy enables open review and standardization, which are critical for building trust and identifying vulnerabilities in complex systems.
The transformation of cryptography from a military-exclusive tool (classical) to a ubiquitous necessity in everyday life (modern) 4 signifies its evolution from a niche "art" to a critical pillar of the digital age. Its ability to provide confidentiality, integrity, authenticity, and non-repudiation 4 is what enables secure banking, e-commerce, and private communication on a global scale. This highlights the profound societal and economic implications of modern cryptographic advancements, making it an indispensable "exact science."
### Table 4: Key Differences: Classical vs. Modern Cryptography
 ![image](https://github.com/user-attachments/assets/73c84e97-c17e-4465-ae11-88f67d33a814)

## 5. Enhancements, Modern Relevance, and Limitations
### 5.1 Strategies to Mitigate Classical Cipher Weaknesses
Throughout history, cryptographers devised various strategies to enhance the security of classical ciphers and mitigate their inherent weaknesses, particularly against frequency analysis:
●	Polyalphabetic Substitution: A significant advancement involved using multiple substitution alphabets instead of a single one. Ciphers like the Vigenère Cipher employed a keyword to select different Caesar shifts for successive letters, thereby obscuring the plaintext's frequency patterns across the ciphertext.1 This made frequency analysis considerably more challenging.
●	Encrypting Multiple Letters (Digraphs/Trigraphs): Instead of substituting individual letters, some ciphers began encrypting pairs (digraphs) or triples (trigraphs) of letters as single units. The Playfair Cipher is a prime example, encrypting digrams using a 5x5 matrix.6 This approach complicates frequency analysis by spreading the statistical properties over multiple characters.
●	Homophonic Substitution: To further obscure letter frequencies, homophonic substitution ciphers assigned multiple ciphertext symbols to a single plaintext letter, especially for high-frequency letters. This technique aimed to "flatten" the frequency distribution in the ciphertext, making it harder to identify common plaintext letters.2
●	Transposition Ciphers: These ciphers operate by rearranging the order of characters within the message rather than substituting them. Examples include columnar transposition, where plaintext is written horizontally and read vertically.8 Transposition ciphers are often combined with substitution ciphers to form "product ciphers," which are more complex and robust, as seen in modern block ciphers like DES.9
●	One-Time Pad: Considered the pinnacle of classical cryptography, the One-Time Pad is theoretically unbreakable if its key is truly random, as long as the message, and used only once.8 This method produces ciphertext with no statistical relationship to the plaintext, making cryptanalysis impossible. It was an improvement over the Vernam cipher.
●	Removing Clues: Practical measures included removing stylistic clues from the plaintext before encryption, such as case, word spacing, and punctuation, to make cryptanalysis harder by reducing the available information for an attacker.19
These various enhancements (polyalphabetic, digram/trigram, homophonic, transposition) can be understood as early attempts to achieve "confusion" and "diffusion" 8, two fundamental principles of modern cipher design. Confusion aims to obscure the relationship between the key and the ciphertext, while diffusion spreads the influence of plaintext statistics over the ciphertext. These classical attempts, while ultimately insufficient by modern standards, represent a crucial conceptual leap in cryptographic thinking, moving beyond simple one-to-one mappings.
While these enhancements made classical ciphers harder to break manually, they also made them significantly more complex to encrypt and decrypt by hand. The Vigenère cipher, for instance, requires careful management of the keyword and multiple alphabets.7 The One-Time Pad, while theoretically unbreakable, is impractical for widespread use due to the immense challenge of secure key distribution.8 This increasing complexity highlights the inherent limitations of manual cryptographic methods and foreshadows the necessity of mechanical and later electronic machines (like the Enigma machine) and eventually computers for practical, robust cryptography.2
### 5.2 Contemporary Applications and Educational Value
Despite their historical significance, classical ciphers like the Shift and Monoalphabetic Substitution Ciphers are not secure for serious modern security needs.6 Their vulnerabilities to brute-force and frequency analysis attacks, easily executed with modern computational power, render them obsolete for protecting sensitive information.
However, these ciphers retain significant contemporary relevance, primarily in educational contexts and niche applications:
●	Educational Value: Classical ciphers serve as excellent teaching tools for introducing basic concepts of cryptography.6 They provide an accessible entry point for understanding fundamental principles such as substitution, keys, plaintext, ciphertext, and the basic mechanisms of encryption and decryption. By studying their weaknesses, students can grasp the concepts of brute-force attacks and frequency analysis, which laid the groundwork for modern cryptography.6 This hands-on exploration helps develop problem-solving skills and a deeper understanding of cryptographic evolution.12 The continued use of classical ciphers as teaching tools is not merely historical curiosity; it serves as a pedagogical bridge. By understanding the simple principles and inherent weaknesses of these ciphers, students can grasp fundamental cryptographic concepts before moving to the mathematical complexity of modern algorithms. This structured learning path is crucial for building a strong foundation in cybersecurity.
●	Modern Niche Applications:
○	Puzzles and Games: Classical ciphers are frequently used in recreational puzzles, escape rooms, and Capture The Flag (CTF) challenges, where their solvability by hand or with simple tools makes them engaging.6
○	Component in Advanced Algorithms: The fundamental concept of substitution from classical ciphers is not entirely discarded but is integrated into more complex modern cryptographic algorithms. For instance, the Advanced Encryption Standard (AES), a widely used symmetric-key cipher, incorporates substitution operations within its S-boxes (Substitution-boxes) as a core component of its encryption process.6 This demonstrates that foundational principles, once understood, can be repurposed and strengthened within new architectural frameworks.
○	Steganography: Substitution ciphers can be coupled with steganography (the art of hiding messages within other messages) to add an additional layer of obscurity, though not necessarily strong security.2
○	Code Obfuscation: Due to their simplicity and lightness, basic substitution techniques (like XOR encryption, a form of substitution) are sometimes used in code obfuscation by developers or in malware to hide sections of code from easy analysis.22
○	Video Games: They can be used to create secret codes that players can use to unlock hidden features or levels within video games.22
The fact that modern algorithms like AES still incorporate substitution (S-boxes) 6 demonstrates that even seemingly "broken" classical concepts are not entirely discarded but are refined and integrated into more complex, multi-layered systems. This highlights a continuous thread in cryptographic design: foundational principles, once understood, can be repurposed and strengthened within new architectural frameworks, emphasizing that cryptographic evolution is often iterative rather than purely revolutionary.
## 6. Conclusion
This report has thoroughly examined the Shift Cipher and the Monoalphabetic Substitution Cipher, two foundational classical cryptographic algorithms. The analysis has detailed their algorithmic principles, explored their Python implementations, and critically assessed their cryptographic strengths and, more significantly, their profound weaknesses.
The Shift Cipher, characterized by its extremely small key space of 26 possibilities, is trivially broken by brute-force attacks and frequency analysis. The Monoalphabetic Substitution Cipher, while boasting a vastly larger key space of 26! permutations, ultimately suffers from the same fundamental flaw: its one-to-one substitution preserves the statistical properties of the plaintext, rendering it highly vulnerable to frequency analysis. Both ciphers, therefore, offer negligible security for any contemporary application requiring robust data protection.
The evolution from these simple classical ciphers to modern cryptography represents a paradigm shift from an "art" relying on manual methods and obscurity to an "exact science" driven by complex mathematics and computational power. Modern cryptography, adhering to Kerckhoffs' Principle, relies on the secrecy of the key rather than the algorithm, providing comprehensive security guarantees including confidentiality, integrity, authenticity, and non-repudiation.
Despite their cryptographic obsolescence, the Shift and Monoalphabetic Substitution Ciphers remain indispensable as pedagogical tools. They serve as accessible entry points for understanding core cryptographic concepts, illustrating the historical progression of the field, and highlighting the continuous arms race between cipher design and cryptanalysis. Their study provides crucial context for appreciating the complexity and necessity of modern cryptographic systems that underpin secure digital communication and transactions globally. These ciphers are valuable learning instruments, not secure communication methods.
## 7. Recommendations for Further Exploration
To deepen the understanding of cryptographic principles and their evolution, the following areas of further exploration are recommended:
●	Advanced Classical Ciphers: Investigate polyalphabetic ciphers, such as the Vigenère Cipher, and various transposition ciphers (e.g., columnar transposition). This will provide insight into how classical cryptography attempted to overcome the limitations of simple substitution by introducing more complex patterns and multiple alphabets.
●	Modern Symmetric-Key Ciphers: Study the Advanced Encryption Standard (AES) as a prime example of a secure block cipher widely used today. Understanding AES will reveal how modern algorithms integrate and enhance classical concepts like substitution (via S-boxes) and permutation (diffusion) within a robust, iterative structure.
●	Modern Asymmetric-Key Cryptography: Explore public-key cryptosystems like RSA (Rivest–Shamir–Adleman) and key exchange protocols such as Diffie-Hellman. This will introduce the fundamental concepts of public-key infrastructure, digital signatures, and secure key distribution, which are critical for modern secure communication over insecure channels.
●	Cryptanalysis Techniques: Delve deeper into advanced cryptanalytic methods beyond basic brute-force and frequency analysis. This includes understanding differential cryptanalysis, linear cryptanalysis, and side-channel attacks, which are used to evaluate the security of modern ciphers.
●	Practical Cryptography Libraries: Experiment with established, peer-reviewed cryptographic libraries in Python, such as the cryptography library. This will provide practical experience in securely implementing modern cryptographic primitives, avoiding common pitfalls associated with custom implementations.
●	Security Best Practices: Familiarize oneself with current security best practices and cryptographic standards (e.g., NIST recommendations). This emphasizes the importance of using established, peer-reviewed modern cryptographic algorithms and protocols for any real-world secure communication, rather than attempting to design or implement novel cryptographic schemes.
## 8. Usage Guide: Executing the Provided Python Code
This section provides clear instructions for executing the provided Python code, interpreting its output, and understanding the practical demonstration of the Shift and Monoalphabetic Substitution Ciphers.
### 8.1 System Requirements
To execute the provided Python code, the following minimal system requirements must be met:
●	Python 3.x: A compatible version of Python 3 (e.g., Python 3.6 or newer) must be installed on the operating system.
●	Standard Python Installation: The code relies solely on Python's built-in functions and standard library modules (ord(), chr(), str.maketrans(), translate()). No external libraries or special dependencies are required.
### 8.2 Step-by-Step Execution Instructions
To run the provided cryptographic cipher demonstration:
1.	Save the Code: Copy the entire Python code block provided in the user query and save it into a text file. Name this file with a .py extension (e.g., ciphers_demo.py).
2.	Open a Terminal/Command Prompt: Launch your system's command-line interface (e.g., Command Prompt on Windows, Terminal on macOS/Linux).
3.	Navigate to Directory: Use the cd command to navigate to the directory where you saved the ciphers_demo.py file. For example: cd /path/to/your/code/directory.
4.	Run the Script: Execute the script using the Python interpreter by typing: python ciphers_demo.py.
5.	Follow Prompts: The script will then prompt you to "Enter plaintext for Shift Cipher:". Type your desired message and press Enter.
6.	Observe Shift Cipher Output: The script will display the plaintext, the fixed key (k=15), and the resulting ciphertext for the Shift Cipher. It will also print a detailed "Module Operation" section for the specific string "ANTOAN", showing the step-by-step numerical transformation of each character.
7.	Follow Prompts for Monoalphabetic Cipher: After the Shift Cipher output, the script will prompt you again: "Enter plaintext for Monoalphabetic Cipher:". Type your desired message and press Enter.
8.	Observe Monoalphabetic Cipher Output: The script will then display the plaintext, the fixed monoalphabetic key, and the resulting ciphertext for the Monoalphabetic Cipher.
### 8.3 Interpreting Outputs
Understanding the output is crucial for grasping the practical operation of these ciphers:
●	Shift Cipher Output:
○	Plaintext: (Note: The code converts your input to uppercase before encryption).
○	Key (k): 15 (This is the fixed shift value used in the demonstration).
○	Ciphertext: (This is the result of applying a shift of 15 to your plaintext. Non-alphabetic characters like spaces are preserved).
○	Module Operation for 'AN TOAN': This section provides a granular breakdown of how each character in "ANTOAN" (no space) is encrypted. It shows the original character, its Unicode ordinal value, the calculation (ord(char) - ord('A') + key) % 26, the resulting numerical position after the shift and modulo operation, and the final encrypted character. For example, for 'A', it shows (65 - 65 + 15) mod 26 = 15, leading to 'P'. This detailed trace allows for direct verification of the cipher's arithmetic. As noted in the report, if your initial plaintext input was "AN TOAN", the actual output for Ciphertext will be "PC IDPC" (preserving the space), which is consistent with the code's logic, despite a potential discrepancy in the user's initial example output. This detailed "Module Operation" output is not just a result; it is a built-in debugging trace. By showing the intermediate steps (ordinal values, modulo arithmetic), it allows the user to trace the algorithm's execution for each character. This practical demonstration is invaluable for truly understanding how the cipher works at a granular level, beyond just seeing the final input/output. It promotes a deeper, hands-on understanding of the cryptographic process.
●	Monoalphabetic Cipher Output:
○	Plaintext:
○	Key: DKVQFIBJWPESCXHTMYAUOLRGZN (This is the fixed, jumbled substitution alphabet used as the key).
○	Ciphertext: (This is the result of substituting each letter from your plaintext with its corresponding letter from the provided key. The plaintext is converted to uppercase before encryption, and non-alphabetic characters are preserved).
The code's handling of non-alphabetic characters (preserving them) and its conversion of input to uppercase highlight practical considerations in cipher implementation. While simple for these classical ciphers, in real-world cryptography, robust handling of diverse character sets, punctuation, and whitespace is crucial. This subtly points to the broader challenge of input sanitization and character encoding in cryptographic systems, where mishandling can introduce vulnerabilities or lead to incorrect results.
### Source extract
1.	An Abridged History of Cryptography Caesar Cipher Vigen`ere Cipher - Washington, truy cập vào tháng 5 24, 2025, https://courses.cs.washington.edu/courses/cse490h1/19wi/exhibit/artifacts/crypto.pdf
2.	History of cryptography - Wikipedia, truy cập vào tháng 5 24, 2025, https://en.wikipedia.org/wiki/History_of_cryptography
3.	The History of Cryptography | IBM, truy cập vào tháng 5 24, 2025, https://www.ibm.com/think/topics/cryptography-history
4.	How Do Classical Cryptography and Modern Cryptography Differ?, truy cập vào tháng 5 24, 2025, https://blog.rheinwerk-computing.com/how-do-classical-cryptography-and-modern-cryptography-differ
5.	Monoalphabetic Cipher in Cryptography - Tutorialspoint, truy cập vào tháng 5 24, 2025, https://www.tutorialspoint.com/cryptography/cryptography_monoalphabetic_cipher.htm
6.	Substitution Ciphers - Dr. Balvinder Taneja, truy cập vào tháng 5 24, 2025, https://drbtaneja.com/substitution-ciphers/
7.	Monoalphabetic and Polyalphabetic Ciphers in Cryptography - DEV Community, truy cập vào tháng 5 24, 2025, https://dev.to/borisgigovic/monoalphabetic-and-polyalphabetic-ciphers-in-cryptography-4fkk
8.	Monoalphabetic Cipher Weakness & Digram/Trigram Analysis - Quizgecko, truy cập vào tháng 5 24, 2025, https://quizgecko.com/learn/monoalphabetic-cipher-weakness-digramtrigram-analysis-qzi2a2
9.	Classical cipher - Wikipedia, truy cập vào tháng 5 24, 2025, https://en.wikipedia.org/wiki/Classical_cipher
10.	Substitution cipher | Algorithm, Encryption & Decryption | Britannica, truy cập vào tháng 5 24, 2025, https://www.britannica.com/topic/substitution-cipher
11.	An introduction to Caesar Cipher in Cryptography - Codedamn, truy cập vào tháng 5 24, 2025, https://codedamn.com/news/cryptography/caesar-cipher-introduction
12.	Cybersecurity and Cryptography Unit 7 – Intro to Cryptography: Classical Ciphers - Fiveable, truy cập vào tháng 5 24, 2025, https://library.fiveable.me/cybersecurity-and-cryptography/unit-7
13.	The Caesar Cipher, Explained | Splunk, truy cập vào tháng 5 24, 2025, https://www.splunk.com/en_us/blog/learn/caesar-cipher.html
14.	Caesar Shift Cipher - Crypto Corner, truy cập vào tháng 5 24, 2025, https://crypto.interactive-maths.com/caesar-shift-cipher.html
15.	The Story of Cryptography: History - GhostVolt, truy cập vào tháng 5 24, 2025, https://www.ghostvolt.com/articles/cryptography_history.html
16.	Introduction to formal Cryptography - An example: The shift cipher - PlanB.network, truy cập vào tháng 5 24, 2025, https://planb.network/courses/d2fd9fc0-d9ed-4a87-9fa3-0fdbb3937e28/7b179ae8-8d15-5e80-a43f-22c970d87b5e
17.	Python | Built-in Functions | ord() | Codecademy, truy cập vào tháng 5 24, 2025, https://www.codecademy.com/resources/docs/python/built-in-functions/ord
18.	Python Ord and Chr | 2 Reliable Python ASCII to Char Tools - IOFLOOD.com, truy cập vào tháng 5 24, 2025, https://ioflood.com/blog/ord-python-and-chr-python-ordinal-value-character-conversions-in-python/
19.	Cracking Classic Ciphers, truy cập vào tháng 5 24, 2025, https://www2.rivier.edu/faculty/vriabov/cs572aweb/Assignments/CrackingClassicCiphers.htm
20.	Python str maketrans() - Create Translation Table | Vultr Docs, truy cập vào tháng 5 24, 2025, https://docs.vultr.com/python/standard-library/str/maketrans
21.	Python String maketrans() Method | GeeksforGeeks, truy cập vào tháng 5 24, 2025, https://www.geeksforgeeks.org/python-string-maketrans-method/
22.	Substitution ciphers? An overview of the basics - StackZero, truy cập vào tháng 5 24, 2025, https://www.stackzero.net/substitution-ciphers/
